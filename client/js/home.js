var first = true;

Template.data.rendered = function () {
    // Check for the various File API support.
    if (window.File && window.FileReader && window.FileList && window.Blob) {
      // Great success! All the File APIs are supported.
      toastr.info('Your browser supports the HTML5 File APIs.', 'Good stuff');
    } else {
      toastr.error('Your browser does not support the HTML5 File APIs.', 'Oh no');
    }

    // Listen for files dropped to upload
    var dropZone = document.getElementById('dropbox');
    dropZone.addEventListener('dragover', handleDragOver, false);
    dropZone.addEventListener('drop', handleFiles, false);  
}

Template.home.rendered = function () {
    if (first){
        var displayed_in = false;
        var displayed_none = false;
        first = false;
    }    
    Deps.autorun(function () {
      if (Meteor.user() && !displayed_in){
        toastr.clear();
        toastr.success("You have signed in succesfully.", "Hello.");
        displayed_in = true;
        displayed_none = false;
      } else if (!displayed_none) {
        toastr.clear();
        toastr.info("No one is currently logged in.", "");
        displayed_none = true;
        displayed_in = false;
      }
    });
}

// Read in a new file
function newRead(text, set) {
    var lines;
    // Check whether the data is generated by logger
    // (and therefore split by new lines) or by the
    // Trintel portal (and therefore split using ;s)
    var dataType = text.indexOf(";");
    if (dataType == -1) {
        lines = text.split("\n");
    } else {
        lines = text.split(";");
    }
    // Previous coordinate
    var prev_lat = 0.0;
    var prev_lng = 0.0;
    // Section starting point
    var start_lat = 0.0;
    var start_lng = 0.0;
    // Section points
    var sec_lats = [];
    var sec_lngs = [];
    // Current section ID
    var current_sec_ID = 0;
    // Amount of generated sections, from current file
    var sec_count = 0;
    var ccc = 0; 
    
    // Read in each line of the current file
    _.each(lines, function(line) {
        var split_line = line.split("|");

        // Time format: hhmmss
        var time = parseFloat(split_line[3]);
        var timeslot;
        // Between 06h00 and 12h00
        if (time >= 6000000 && time < 12000000) {
            timeslot = 'A';
        }
        // Between 12h00 and 18h00
        if (time >= 12000000 && time < 18000000) {
            timeslot = 'B';
        }
        // Between 18h00 and 06h00
        else {
            timeslot = 'C';
        }

        // Generate lat and lng values
        var lat = parseFloat(split_line[0]) / 1000000;
        var lng = parseFloat(split_line[1]) / 1000000;

        // Read random ID for coordinate
        var randnum = parseFloat(split_line[4]);

        // Check if coordinate has been added before
        var checker = Coordinates.findOne({ lat: lat, lng: lng, randnum: randnum});

        ccc += 1;

        // Check that latitude and longitude are numbers
        if (!isNaN(lat) && !isNaN(lng) && !checker) {
            //console.log("Working");
            // Compare distance to previous section start
            var sec_dist = distToPrev(lat, lng, start_lat, start_lng);
            sec_dist = Math.abs(sec_dist);

            // Point not in a previously generated section
            if (sec_dist > 20) {
                // If not first section for file, finalise previous section first
                if (sec_count > 0) {
                    // Calculate average section line by using least squares method

                    // Declare some variables
                    var lat_sum = 0;
                    var lng_sum = 0;
                    var lat_mean = 0;
                    var lng_mean = 0;
                    var lat_sqrd = 0;
                    var pair_sqrd = 0;

                    for (var i = 0; i < sec_lats.length; i++) {
                        // Calculate the lat and lng sums
                        lat_sum += sec_lats[i];
                        lng_sum += sec_lngs[i];

                        // Calculate the sum of each pair multiplied
                        pair_sqrd += sec_lats[i] * sec_lngs[i];

                        // Calculate the sum of lats squared
                        lat_sqrd += sec_lats[i] * sec_lats[i];
                    }

                    // Calculate latitude and longitude means
                    lat_mean = lat_sum / sec_lats.length;
                    lng_mean = lng_sum / sec_lngs.length;

                    // Calculate the slope, m
                    var m = (pair_sqrd - (lat_sum * lng_sum / sec_lats.length)) / (lat_sqrd - (lat_sum * lat_sum / sec_lngs.length));

                    // Calculate b = y_mean - m*x_mean
                    var b = lng_mean - (m * lat_mean);

                    // Form new line with lng = m*lat + b
                    var s_lng = m*sec_lats[0] + b; 
                    var f_lng = m*sec_lats[sec_lats.length - 1] + b;

                    // Create start, end and centre points
                    var start_obj = {
                        lat: sec_lats[0],
                        lng: s_lng
                    };
                    var finish_obj = {
                        lat: sec_lats[sec_lats.length - 1],
                        lng: f_lng
                    };
                    var segment_centre = {
                        lat: (start_obj.lat + finish_obj.lat)/2,
                        lng: (start_obj.lng + finish_obj.lng)/2
                    }



                    // Calculate length of new line
                    var line_length = distToPrev(start_obj.lat, start_obj.lng, finish_obj.lat, finish_obj.lng);

                    // See if in another section's bounds
                    var in_bounds = false;
                    var intersections = 0;
                    var secs = Sections.find().fetch();
                    _.each(secs, function(section) {
                        // Check whether the section is within reach before doing any calculations
                        var dist_to_centre = Math.abs(distToPrev(section.bounds.centre.lat, section.bounds.centre.lng, segment_centre.lat, segment_centre.lng));
                        if(dist_to_centre < 22) {   
                            //Find the four lines that define the bounding box
                            //Source: http://mathforum.org/library/drmath/view/53254.html
                            //For each of these lines:
                            //1. Get y = m2x + b2
                            //2. Subtract from current line to find intersection x (latitude): 
                            //      y - y = (m1 - m2)x + (b1 - b2)
                            //      0 = (m1-m2)x + (b1-b2)
                            //      x = -(b1-b2)/(m1-m2)
                            //3. Get intersection y (longitude): y = mx+b
                            //4. See if point (x,y) is on the line section
                            //      i.e. is start.lat < intersect_lat < end.lat ?
                            //5. Set in_bounds appropriately

                            // Get the four latlng intersections
                            var lat_short0 = -(b - section.short_bb.b0) / (m - section.short_bb.m);
                            var lat_short1 = -(b - section.short_bb.b1) / (m - section.short_bb.m);
                            var lat_long0 = -(b - section.long_bb.b0) / (m - section.long_bb.m);
                            var lat_long1 = -(b - section.long_bb.b1) / (m - section.long_bb.m);

                            var lng_short0 = m * lat_short0 + b;
                            var lng_short1 = m * lat_short1 + b;
                            var lng_long0 = m * lat_long0 + b;
                            var lng_long1 = m * lat_long1 + b;

                            // Use the orientation method to determine if intersections occur
                            // Source for algorithm: http://www.dcs.gla.ac.uk/~pat/52233/slides/Geometry1x1.pdf
                            var hit;
                            var inters = [];

                            // Check short 0
                            hit = checkIntersection(start_obj, finish_obj, section.bounds.cnr1, section.bounds.cnr2);
                            if (hit) {
                                var temp_obj = {
                                    lat: lat_short0,
                                    lng: lng_short0
                                };                                
                                inters.push(temp_obj);
                                
                            }

                            // Check short 1
                            hit = checkIntersection(start_obj, finish_obj, section.bounds.cnr3, section.bounds.cnr4);
                            if (hit) {
                                var temp_obj = {
                                    lat: lat_short1,
                                    lng: lng_short1
                                };
                                inters.push(temp_obj);
                            }

                            // Check long 0
                            hit = checkIntersection(start_obj, finish_obj, section.bounds.cnr1, section.bounds.cnr3);
                            if (hit) {
                                var temp_obj = {
                                    lat: lat_long0,
                                    lng: lng_long0
                                };
                                inters.push(temp_obj);
                            }

                            // Check long 1
                            hit = checkIntersection(start_obj, finish_obj, section.bounds.cnr2, section.bounds.cnr4);
                            if (hit) {
                                var temp_obj = {
                                    lat: lat_long1,
                                    lng: lng_long1
                                };
                                inters.push(temp_obj);
                            }

                            // If a section was intersected
                            if(inters[0]) {
                                var temp_seg;
                                in_bounds = true;
                                // If the line runs through a section
                                if (inters.length > 1){
                                    temp_seg = {
                                        start:      {
                                                        lat: inters[0].lat,
                                                        lng: inters[0].lng
                                                    },
                                        finish:     {
                                                        lat: inters[1].lat,
                                                        lng: inters[1].lng
                                                    }
                                    }
                                } 
                                // If the line only intersects section once
                                else {

                                    var distFromStart = distToPrev(start_obj.lat, start_obj.lng, section.bounds.centre.lat, section.bounds.centre.lng);
                                    var distFromFinish = distToPrev(finish_obj.lat, finish_obj.lng, section.bounds.centre.lat, section.bounds.centre.lng);
                                    if (distFromStart < distFromFinish) {

                                       temp_seg = {
                                            start:      {
                                                            lat: inters[0].lat,
                                                            lng: inters[0].lng
                                                        },
                                            finish:     {
                                                            lat: start_obj.lat,
                                                            lng: start_obj.lng
                                                        }
                                        } 

                                    } else {

                                        temp_seg = {
                                            start:      {
                                                            lat: inters[0].lat,
                                                            lng: inters[0].lng
                                                        },
                                            finish:     {
                                                            lat: finish_obj.lat,
                                                            lng: finish_obj.lng
                                                        }
                                        }

                                    }
                                }

                                // Calculate ratio of segment in section
                                var ratio = distToPrev(temp_seg.start.lat, temp_seg.start.lng, temp_seg.finish.lat, temp_seg.finish.lng) /
                                            distToPrev(start_obj.lat, start_obj.lng, finish_obj.lat, finish_obj.lng);

                                // Adjust section average position and count according to ratio
                                var temp_section = {
                                                        start:  section.start,
                                                        finish: section.finish
                                                    }
                                var new_pos = calcNewPos(ratio, section.count, temp_seg, temp_section);
                                Sections.update(    {_id: section._id},
                                                    { $set: {start: new_pos.start, finish: new_pos.finish, count: section.count+ratio}});

                                // Reset the lats array
                                sec_lats = [];
                                sec_lngs = [];

                            }
                        }
                    })
                    // Intersects a previous section area
                    if (in_bounds) {}
                    //Does not intersect previous section sufficiently
                    else {
                        // Calculate bounding box
                        var new_bb = generateBB(start_obj, finish_obj, m);

                        // Create sections object
                        var section_obj = {
                            sec_ID: current_sec_ID,
                            start:  start_obj,
                            finish: finish_obj,
                            bounds: new_bb.bb_obj,
                            short_bb: new_bb.short_obj,
                            long_bb: new_bb.long_obj,
                            count: 1
                        };

                        // Update sections database
                        Sections.insert(section_obj);

                        // Reset the lats array
                        sec_lats = [];
                        sec_lngs = [];
                    }
                }

                // Set start of section
                start_lat = lat;
                start_lng = lng;

                // Update section points
                sec_lats.push(lat);
                sec_lngs.push(lng);

                if (sec_count == 0) {
                    // Generate section ID
                    var section_check = Sections.findOne({});
                    if(section_check){
                        current_sec_ID = section_check.sec_ID + 1;
                    } else {
                        current_sec_ID = 1;
                    }
                } else {
                    current_sec_ID += 1;
                }
                

                // Create coordinate object
                var coord_obj = {
                    timeslot:   timeslot,
                    lat:        lat,
                    lon:        lng,
                    speed:      parseFloat(split_line[2]), // unit: knots
                    type:       "A",
                    set:        set,
                    section:    current_sec_ID,
                    randnum:    randnum
                }

                // Push coordinate obj to database
                Coordinates.insert(coord_obj);

                // Update sections counter
                sec_count += 1;
            }

            // Point in the previously generated section
            else {
                // Update section points
                sec_lats.push(lat);
                sec_lngs.push(lng);

                // Create coordinate object
                var coord_obj = {
                    timeslot:   timeslot,
                    lat:        lat,
                    lon:        lng,
                    speed:      parseFloat(split_line[2]), // unit: knots
                    type:       "A",
                    set:        set,
                    section:    current_sec_ID,
                    randnum:    randnum
                }

                // Push coordinate obj to database
                Coordinates.insert(coord_obj);
            }
        }
    });
}

// Calculates the new avergae position of a section
function calcNewPos(ratio, count, segment, section) {
    var new_start = {
                        lat:    ((segment.start.lat*ratio)+(section.start.lat*count))/(ratio+count),
                        lng:    ((segment.start.lng*ratio)+(section.start.lng*count))/(ratio+count)
                    }

    var new_finish = {
                        lat:    ((segment.finish.lat*ratio)+(section.finish.lat*count))/(ratio+count),
                        lng:    ((segment.finish.lng*ratio)+(section.finish.lng*count))/(ratio+count)
                    }

    var new_pos = {
                        start:  new_start,
                        finish: new_finish
                    }
    return new_pos;
}

// Checks whether lines, defined by 2x start and end points, intersect
// Uses getOrientation
// Returns boolean result
function checkIntersection(p1, p2, p3, p4){
    var dir1 = getOrientation(p1, p2, p3);
    var dir2 = getOrientation(p1, p2, p4);
    var dir3 = getOrientation(p3, p4, p1);
    var dir4 = getOrientation(p3, p4, p2);

    if (dir1 != dir2 && dir3 != dir4){
        return true;
    } else {
        return false;
    }
}

// Calculate the orientation of line segment defined by 3 points
// Return:
// 0 - points are colinear
// 1 - counterclockwise
// 2 - clockwise
function getOrientation (p1, p2, p3) {
    var val = (p2.lng - p1.lng) * (p3.lat - p2.lat) -
              (p2.lat - p1.lat) * (p3.lng - p2.lng);
    if (val == 0) {
        return 0;
    } else if (val > 0){
        return 1;
    } else {
        return 2;
    }
}

// Generate the bounding box for a given line
function generateBB(start_obj, finish_obj, m) {
    // Calculate bounding box
    // Perpendicular line: y = (-1/m)x + b
    /*  (lat1,lng1) |-----------------------| (lat3,lng3)
                    |                       |
                    |-----------------------|
                    |                       |
        (lat2,lng2) |-----------------------| (lat4, lng4)
    */
    // Formula: x1 = x0 + D/sqrt(1+m1^2), with m1 = -1/m

    // Calculate the four corners
    var m1 = -1/m; // Slope for normal line
    var b0 = start_obj.lng - (start_obj.lat * m1); // Y-intercept for normal line
    var b1 = finish_obj.lng - (finish_obj.lat * m1); // Y-intercept for normal line
    var d = 0.000035 // Approximately 1.5m on either side of line
    // Corner 1
    var lat1 = start_obj.lat + ( d / Math.sqrt( 1+(m1 * m1) ) );
    var lng1 = (m1 * lat1) + b0;
    var cnr1 = {
        lat: lat1,
        lng: lng1
    }
    // Corner 2
    var lat2 = start_obj.lat - ( d / Math.sqrt( 1+(m1 * m1) ) );
    var lng2 = (m1 * lat2) + b0;
    var cnr2 = {
        lat: lat2,
        lng: lng2
    }
    // Corner 3
    var lat3 = finish_obj.lat + ( d / Math.sqrt( 1+(m1 * m1) ) );
    var lng3 = (m1 * lat3) + b1;
    var cnr3 = {
        lat: lat3,
        lng: lng3
    }
    // Corner 4
    var lat4 = finish_obj.lat - ( d / Math.sqrt( 1+(m1 * m1) ) );
    var lng4 = (m1 * lat4) + b1;
    var cnr4 = {
        lat: lat4,
        lng: lng4
    }

    // Centre point
    var clat = (lat1 + lat2 + lat3 + lat4) / 4;
    var clng = (lng1 + lng2 + lng3 + lng4) / 4;
    var centre = {
        lat: clat,
        lng: clng
    }

    // Generate the bounding box object
    var bb_obj = {
        cnr1: cnr1,
        cnr2: cnr2,
        cnr3: cnr3,
        cnr4: cnr4,
        centre: centre
    }

    // Store line attributes for later use
    var short_obj = {
        m: m1,
        b0 : b0,
        b1 : b1
    }
    var long_b0 = cnr1.lng - (m*cnr1.lat); // b = y-mx
    var long_b1 = cnr2.lng - (m*cnr2.lat); // b = y-mx
    var long_obj = {
        m: m,
        b0 : long_b0,
        b1 : long_b1
    }

    //return bb_obj, short_obj, long_obj;
    return {
        bb_obj: bb_obj,
        short_obj: short_obj,
        long_obj: long_obj
    };
}

// Converts GPS data points to decimal coordinates
// Decimal value = Degrees + (Minutes/60) + (Seconds/3600)
function convertToDecimal(val, latlng, dir) {
    var dec_result = 0;
    if (latlng == "lat"){
        dec_result += parseFloat(val.substring(0,2));
        dec_result += parseFloat(val.substring(2)) / 60;
        if (dir == "S"){
            dec_result *= -1.0;
        }
    }
    else if (latlng == "lng"){
        dec_result += parseFloat(val.substring(0,3));
        dec_result += parseFloat(val.substring(3)) / 60;
        if (dir == "W"){
            dec_result *= -1.0;
        }
    }
    return dec_result;
}

// Calculates the distance between the previous coordinate and the new one
// for the purpose of a "Trackpoint Distance Threshold" filter
function distToPrev(lat1, lng1, lat2, lng2) {
    // Using the Haversine formula
    // a = sin²(Δφ/2) + cos φ1 ⋅ cos φ2 ⋅ sin²(Δλ/2)
    // c = 2 ⋅ atan2( √a, √(1−a) )
    // d = R ⋅ c 
    // Credits: http://www.movable-type.co.uk/scripts/latlong.html
    var R = 6371000; // metres
    var radlat1 = degToRad(lat1);    
    var radlat2 = degToRad(lat2);
    var deltaLat = degToRad(lat2 - lat1);
    var deltaLng = degToRad(lng2 - lng1);

    var a = (Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2)) 
            + ( (Math.cos(radlat1) * Math.cos(radlat2))
            * (Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2)) ); 
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    var d = R * c;

    return d;
}

// Converts degrees to radians
function degToRad(degrees) {
    return (degrees * Math.PI / 180);
}

// Handles file upload
function handleFiles(e) {
    e.stopPropagation();
    e.preventDefault();

    var files = e.dataTransfer.files;

    var output = [];
    var set = 0;

    for (var i = 0, f; f = files[i]; i++) {
        var reader = new FileReader();
        reader.onload = function(e) {
            var text = reader.result;
            newRead(text, set);
            set += 1;
        }

        reader.readAsText(f);
    }

    toastr.info("Coordinates succesfully added to the database.", "Done")
}

function handleDragOver(e) {
    e.stopPropagation();
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
  }

// Set sign up field to only ask for username
Accounts.ui.config({
    passwordSignupFields: 'USERNAME_ONLY'
});



